<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <header> 


    </header>
    <p>1) Esta ECMAScript 1 (ES1, 1997), ECMAScript 2 (ES2, 1998), ECMAScript 3 (ES, 1999), ECMAScript 5 (ES5, 2009), ECMAScript 2015 (ES5), ECMAScript 2016 (ES7), ECMAScript 2017 (ES8), ECMAScript 2018 (ES9), ECMAScript 2019 (ES10) y ECMAScript 2020 (ES11).</p>
    <p>2) Se puede integrar de 2 maneras: <ul>
            <li>Insertando el codigo de JS con la etiqueta "&lt;script&gt; &lt;/script&gt;" en el head o en el body del HTML</li><br>
            <li> agregandolo como un archivo separado con "&lt;script src="Origen del archivo JS"&gt; &lt;/script&gt;".</li>
        </ul>
    </p>
    <p>3) JavaScript tiene 3 tipos de variables: <ul>
        <li>var: declara una variable, opcionalmente la inicia a un valor</li>
        <li>let: declara una variable local con ámbito de bloque, opcionalmente la inicia a un valor.</li>
        <li>const: Declara un nombre de constante de solo lectura y ámbito de bloque.</li>
    </ul> <br>
    JavaScript tiene 9 tipos de datos, 6 primitivos, 3 modernos. <br>
    Los primitivos son: <ul>
        <li>Undefined: declara un nombre de constante de solo lectura y ámbito de bloque.</li>
        <li>Boolean: en ciencias de informática, un boolean es un dato lógico que solo puede tener los valores true o false.</li>
        <li>Number: en JavaScript, Number es un tipo de datos numérico (double-precision 64-bit floating point format (IEEE 754)). En otros lenguajes de programación puede existir diferentes tipos numéricos, por ejemplo: Integers, Floats, Doubles, or Bignums.</li>
        <li>String: En JavaScript, un String es uno de los valores primitivos y el objeto String es un envoltorio alrededor de un String primitivo.</li>
        <li>BigInt: En JavaScript, BigInt es un tipo de dato numerico que puede representar números enteros en el formato de precision arbitrario.</li>
        <li>Symbol: es un objeto incorporado cuyo constructor devuelve un symbol primitivo — también llamado Symbol value o simplemente Symbol — que está garantizado que sea único. Los Symbols se utilizan a menudo para añadir claves de propiedades únicas a un objeto que no sean iguales a las claves que cualquier otro código pueda añadir al objeto, y que están ocultas de cualquier mecanismo que otro código utilice normalmente para acceder al objeto. Esto permite una forma de encapsulation débil, o una forma débil de ocultación de información. <br>
        Se garantiza que cada llamada a Symbol() devuelve un único Symbol. Cada llamada a Symbol.for("key") devolverá siempre el mismo Symbol para un valor dado de "key". Cuando se llama a Symbol.for("key"), si se puede encontrar un símbolo con la clave dada en el registro global de símbolos, se devuelve ese Symbol. En caso contrario, se crea un nuevo Symbol, se añade al registro global de Symbols con la clave dada y se devuelve.</li>
    </ul>
        Los modernos son: <ul>
            <li>Null: tipo primitivo especial que tiene un uso adicional para su valor: si el objeto no se hereda, se muestra "null"</li>
            <li>Object: tipo estructural especial que no es de datos pero para cualquier instancia de objeto construido que también se utiliza como estructuras de datos: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date y casi todo lo hecho con la palabra clave "new"</li>
            <li>Function: esta simplemente es una forma abreviada para funciones, aunque cada constructor de funciones se deriva del constructor "Object".</li>
        </ul><br>

        Las expresiones regulares en JS son una secuencia de caracteres que forman un patron, son utilizados para filtrar informacion en una cadena de caracteres, y tambien son considerados objetos. Se pueden construir de 2 formas diferentes: <ul> 
            <li> Usando una expresion regular literal, que consiste en un patrón encerrado entre barras (let re = /ab+c/;)</li><br>
            <li> Llamando a la función constructora del objeto RegExp, de la siguiente manera (let re = new RegExp('ab+c');).</li>
        </ul>
    </p>
    <p>4) Las 7 formas de declarar una funcion en JS son las siguientes: 
        <ul>
            <li>Function Declaration: se crea con la palabra "function", seguido obligatoriamente de un nombre que la identifique, una lista de parámetros entre paréntesis, que puede estar vacia, y llaves {}, que delimitaran el contenido de nuestro grupo de sentencias. <img src="Imagenes/function.png" alt="Function"> <br><br>
            
            Otra caracteristica que tienen las funciones por defecto es devolver el valor "undefined", para evitar esto, y devolver un valor diferente, se utiliza la instruccion "return". <br>
            <img src="Imagenes\function_return.png" alt="Function Return"><br><br>

            Este tipo de funciones son compatibles con el "hoisting", una caracteristica de JS, por la cual las definiciones se ejecutan al principio de la ejecución del código.
            </li><br>

            <li>Function expression: esta es muy similar a la anterior, solo que la diferencia es que la definicion de nuestra nueva funcion no comienza por instruccion "function", sino que comienza creando una variable en donde esta se aloja (preferiblemente se utiliza "const", ya que no puede ser modificada), y el nombre de la funcion es opcional. <br>
             <img src="Imagenes/Function_expression.png" alt="Function Expression"><br><br>
            
            Otra diferencia con la funcion anterior es que estas no son compatibles con el "hoisting". <br><br>
            </li>

            <li>IIFE (Immediately Invoked Function Expression): esta funcion es caracterizada por ser de un unico uso. Para crear una función de este tipo deberemos crearla en un operador de agrupación (). Seguido de (), lo que posibilitará el interpretado directamente en el motor de JavaScript. <br>
            <img src="Imagenes/IIFE.png" alt="IIFE"><br><br>
            </li>

            <li>Shorthand method definition: esta orma de crear las funciones puede ser utilizado como método en la declaración de un objeto o en las clases de ES6. Para crear este tipo de función debemos asignar un nombre de función seguido de una lista de parámetros entre paréntesis y los símbolos de llaves para delimitar el cuerpo de las instrucciones. <br>
            <img src="Imagenes/Shorthand_Method_Definition.png" alt="Shorthand method definition"><br><br>
            </li>

            <li>Arrow function: esta es otra de las novedades de ES6, la forma de crear estas funciones es la siguiente: primero definiremos la lista de parámetros, en caso de ser necesario, entre paréntesis seguido del símbolo "=>" y las "{}" para indicar las instrucciones que se van a realizar. Además de la sintaxis que es diferente, este tipo de funciones tienen las siguientes características: <ul>
                <li>Las "arrow function" no crean su propio contexto al ejecutarse. Al contrario que las "function expression" o las "function declaration" que crea su propio contexto.</li>
                <li>Las "arrow function" son anónimas.</li>
                <li>El objeto "arguments" no se encuentra en el contexto de la función.</li>
                <li>Si al definir la función no utilizamos el símbolo de las llaves. La función devolverá como resultado de la función el resultado de la ejecución de la instrucción que hayamos indicado.</li>
            </ul> <br> <img src="Imagenes/Arrow_Function.png" alt="Arrow Function"> <br><br>
           </li>

            <li>Generator function: esta es caracterizada por permitirnos parar o salir de la función en un punto dentro del conjunto de instrucciones que forman nuestra función y retornar posteriormente la ejecución desde el punto en el que paramos anteriormente. La sintaxis de estas funciones es igual a las "function declaration" o "function expression". Sólo debemos utilizar el símbolo "*" al comienzo de la definición de nuestra función. <br>
            <img src="Imagenes/Generator_function.png" alt="Generator Function"></li> <br><br>

            <li>Function constructor: esta es forma bastante inusual de declarar las funciones, ya que se caracteriza por crear funciones. Podremos crear una variable que invoque a un objeto Function. Cuando invoquemos a este objeto podremos enviar todos los argumentos que deseemos. Los primeros n argumentos serán los parámetros de nuestra función y el último argumento será el código de nuestra función. <br>
                <img src="Imagenes/Function_Constructor.png" alt="Function Constructor">
            </li> <br><br>
        </ul>
    </p>

    <p>5) Los operadores de JavaScript son: <ul>
        <li>Operadores de asignación: un operador de asignación asigna un valor a su operando izquierdo basándose en el valor de su operando derecho. El operador de asignación simple es igual (=), que asigna el valor de su operando derecho a su operando izquierdo. Es decir, X = Y asigna el valor de Y a X. <br>
        Tambien hay operadores de asignación compuestos que son una abreviatura de las operaciones enumeradas en la siguiente tabla: <br>
            <table border="1">
                
                  <tr>
                    <th>Nombre</th>
                    <th>Operador abreviado</th>
                    <th>Significado</th>
                 </tr>
                <tr>
                   <td>Asignación</td>
                   <td>x = y</td>
                   <td>x = y</td> 
                </tr>
                <tr>
                    <td>Asignación de adición</td>
                    <td>x += y</td>
                    <td>x = x + y</td>
                </tr>
                <tr>
                    <td>Asignación de resta</td>
                    <td>x -= y</td>
                    <td>x = x - y</td>
                </tr>
                <tr>
                    <td>Asignación de multiplicación</td>
                    <td>x *= y</td>
                    <td>x = x * y</td>
                </tr>
                <tr>
                    <td>Asignación de división</td>
                    <td>x /= y</td>
                    <td>x = x / y</td>
                </tr>
                <tr>
                    <td>Asignación de residuo</td>
                    <td>x %= y</td>
                    <td>x = x % y</td>
                </tr>
                <tr>
                    <td>Asignación de exponenciación</td>
                    <td>x **= y</td>
                    <td>x = x ** y</td>
                </tr>
                <tr>
                    <td>Asignación de desplazamiento a la izquierda</td>
                    <td>x &lt;&lt;= y</td>
                    <td>x = x &lt;&lt; y</td>
                </tr>
                <tr>
                    <td>Asignación de desplazamiento a la derecha</td>
                    <td>x &gt;&gt;= y</td>
                    <td>x = x &gt;&gt; y</td>
                </tr>
                <tr>
                    <td>Asignación de desplazamiento a la derecha sin signo</td>
                    <td>x &lt;&lt;&lt;= y</td>
                    <td>x = x &lt;&lt;&lt; y</td>
                </tr>
                <tr>
                    <td>Asignación AND bit a bit</td>
                    <td>x &= y</td>
                    <td>x = x & y</td>
                </tr>
                <tr>
                    <td>Asignación XOR bit a bit</td>
                    <td>x ^= y</td>
                    <td>x = x ^ y</td>
                </tr>
                <tr>
                    <td>Asignación OR bit a bit</td>
                    <td>x |= y</td>
                    <td>x = x | y</td>
                </tr>
                <tr>
                    <td>Asignación AND lógico</td>
                    <td>x &&= y</td>
                    <td>x && (x = y)</td>
                </tr>
                <tr>
                    <td>Asignación OR lógico</td>
                    <td>x ||= y</td>
                    <td>x || (x = y)</td>
                </tr>
                <tr>
                    <td>Asignación de anulación lógica</td>
                    <td>x ??= y</td>
                    <td>x ?? (x = y)</td>
                </tr>    
            </table> <br>
            
            Cabe resaltar que algunas estas expresiones pueden ser encadenadas, ya que cada asignacion se evalúa de derecha a izquierda. Aca hay un par de ejemplos: <ul>
                <li>w = z = x = y es equivalente a w = (z = (x = y)) o x = y; z = y; w = y</li>
                <li>z += x *= y es equivalente e z += (x *= y) o tmp = x * y; x *= y; z += tmp (salvo que sin tmp).</li>
            </ul>
        </li> <br>
        <li>
        Operadores de comparación: un operador de comparación compara sus operandos y devuelve un valor lógico en función de si la comparación es verdadera (true) o falsa (false). Los operandos pueden ser valores numéricos, de cadena, lógicos u objetos. Las cadenas se comparan según el orden lexicográfico estándar, utilizando valores Unicode. En la mayoría de los casos, si los dos operandos no son del mismo tipo, JavaScript intenta convertirlos a un tipo apropiado para la comparación. Este comportamiento generalmente resulta en comparar los operandos numéricamente. Las únicas excepciones a la conversión de tipos dentro de las comparaciones involucran a los operadores === y !==, que realizan comparaciones estrictas de igualdad y desigualdad. Estos operadores no intentan convertir los operandos a tipos compatibles antes de verificar la igualdad. La siguiente tabla describe los operadores de comparación en términos de este código de ejemplo: <br> 
        var var1 = 3;
        var var2 = 4; <br>

        <table border="1">
            <tr>
                <th>Operador</th>
                <th>Descripción</th>
                <th>Ejemplos que devuelven</th>
            </tr>
            <tr>
                <td>Igual (==)</td>
                <td>Devuelve true si los operandos son iguales.</td>
                <td>3 == var1 <br>
                    "3" == var1 <br>
                    3 == '3'</td>
            </tr>
            <tr>
                <td>No es igual (!=)</td>
                <td>Devuelve true si los operandos no son iguales.</td>
                <td>var1 != 4<br>
                    var2 != "3"</td>
            </tr>
            <tr>
                <td>Estrictamente igual (===)</td>
                <td>Devuelve true si los operandos son iguales y del mismo tipo. Consulta también Object.is y similitud en JS.</td>
                <td>3 === var1</td>
            </tr>
            <tr>
                <td>Desigualdad estricta (!==)</td>
                <td>Devuelve true si los operandos son del mismo tipo pero no iguales, o son de diferente tipo.</td>
                <td>var1 !== "3"<br>
                    3 !== '3'</td>
            </tr>
            <tr>
                <td>Mayor que (>)</td>
                <td>Devuelve true si el operando izquierdo es mayor o igual que el operando derecho.</td>
                <td>var2 >= var1 <br>
                 var1 >= 3</td>
            </tr>
            <tr>
                <td>Mayor o igual que (>=)</td>
                <td>Devuelve true si el operando izquierdo es mayor o igual que el operando derecho.</td>
                <td>var2 >= var1 <br>
                     var1 >= 3</td>
            </tr>
            <tr>
                <td>Menor que (&lt;)</td>
                <td>Devuelve true si el operando izquierdo es menor o igual que el operando derecho.</td>
                <td>var1 &lt; var2 <br>
                    "2" &lt; 12</td>
            </tr>
            <tr>
                <td>Menor o igual (&lt;=)</td>
                <td>Devuelve true si el operando izquierdo es menor o igual que el operando derecho.</td>
                <td>var1 &lt;= var2 var2 &lt;= 5</td>
            </tr>
        </table>
        </li> <br>
        <li>Operadores aritméticos: un operador aritmético toma valores numéricos (ya sean literales o variables) como sus operandos y devuelve un solo valor numérico. Los operadores aritméticos estándar son suma (+), resta (-), multiplicación (*) y división (/). Estos operadores funcionan como lo hacen en la mayoría de los otros lenguajes de programación cuando se usan con números de punto flotante (en particular, ten en cuenta que la división entre cero produce Infinity). Por ejemplo: <br>
            1 / 2; // 0.5 <br>
            1 / 2 == 1.0 / 2.0; // Esto es true <br>
        Además de las operaciones aritméticas estándar (+, -, *, /), JavaScript proporciona los operadores aritméticos enumerados en la siguiente tabla:

        <table border="1">
            <tr>
                <th>Operador</th>
                <th>Descripción</th>
                <th>Ejemplos que devuelven true</th>
            </tr>
            <tr>
                <td>Residuo (%)</td>
                <td>Operador binario. Devuelve el resto entero de dividir los dos operandos.</td>
                <td>
                    12 % 5 devuelve 2.
                </td>
            </tr>
            <tr>
                <td>Incremento (++)</td>
                <td>Operador unario. Agrega uno a su operando. Si se usa como operador prefijo (++x), devuelve el valor de su operando después de agregar uno; si se usa como operador sufijo (x++), devuelve el valor de su operando antes de agregar uno.</td>
                <td>Si x es 3, ++x establece x en 4 y devuelve 4, mientras que x++ devuelve 3 y , solo entonces, establece x en 4.</td>
            </tr>
            <tr>
                <td>Decremento (--)</td>
                <td>Operador unario. Resta uno de su operando. El valor de retorno es análogo al del operador de incremento.</td>
                <td>Si x es 3, entonces --x establece x en 2 y devuelve 2, mientras que x-- devuelve 3 y, solo entonces, establece x en 2.</td>
            </tr>
            <tr>
                <td>Negación unaria (-)</td>
                <td>Operador unario. Devuelve la negación de su operando.</td>
                <td>Si x es 3, entonces -x devuelve -3.</td>
            </tr>
            <tr>
                <td>Positivo unario (+)</td>
                <td>Operador unario. Intenta convertir el operando en un número, si aún no lo es.</td>
                <td>+"3" devuelve 3. +true devuelve 1.</td>
            </tr>
            <tr>
                <td>Operador de exponenciación (**)</td>
                <td>Calcula la base a la potencia de exponente, es decir, baseexponente</td>
                <td>2 ** 3 returns 8. 10 ** -1 returns 0.1.</td>
            </tr>
        </table>
        </li> <br>
        <li>Operadores bit a bit: un operador bit a bit trata a sus operandos como un conjunto de 32 bits (ceros y unos), en lugar de números decimales, hexadecimales u octales. Por ejemplo, el número decimal nueve tiene una representación binaria de 1001. Los operadores bit a bit realizan sus operaciones en tales representaciones binarias, pero devuelven valores numéricos estándar de JavaScript. <br>
         La siguiente tabla resume los operadores bit a bit de JavaScript: 
        
         <table border="1">
            <tr>
                <th>Operador</th>
                <th>Uso</th>
                <th>Descripción</th>
            </tr>
            <tr>
                <td>AND a nivel de bits</td>
                <td>a & b</td>
                <td>Devuelve un uno en cada posición del bit para los que los bits correspondientes de ambos operandos son unos.</td>
            </tr>
            <tr>
                <td>OR a nivel de bits</td>
                <td>a | b</td>
                <td>Devuelve un cero en cada posición de bit para el cual los bits correspondientes de ambos operandos son ceros.</td>
            </tr>
            <tr>
                <td>XOR a nivel de bits</td>
                <td>a ^ b</td>
                <td>Devuelve un cero en cada posición de bit para la que los bits correspondientes son iguales. [Devuelve uno en cada posición de bit para la que los bits correspondientes son diferentes].</td>
            </tr>
            <tr>
                <td>NOT a nivel de bits</td>
                <td>~ a</td>
                <td>Invierte los bits de su operando.</td>
            </tr>
            <tr>
                <td>Desplazamiento a la izquierda</td>
                <td>a &lt;&lt; b</td>
                <td>Desplaza a en representación binaria b bits hacia la izquierda, desplazándose en ceros desde la derecha.</td>
            </tr>
            <tr>
                <td>Desplazamiento a la derecha de propagación de signo</td>
                <td>a >> b</td>
                <td>Desplaza a en representación binaria b bits a la derecha, descartando los bits desplazados.</td>
            </tr>
            <tr>
                <td>Desplazamiento a la derecha de relleno cero</td>
                <td>a >>> b</td>
                <td>Desplaza a en representación binaria b bits hacia la derecha, descartando los bits desplazados y desplazándose en ceros desde la izquierda.</td>
            </tr>
            </table>
        </li> <br>

        <li>Operadores lógicos: los operadores lógicos se utilizan normalmente con valores booleanos (lógicos); cuando lo son, devuelven un valor booleano. Sin embargo, los operadores && y || en realidad devuelven el valor de uno de los operandos especificados, por lo que si estos operadores se utilizan con valores no booleanos, pueden devolver un valor no booleano. Los operadores lógicos se describen en la siguiente tabla.

            <table border="1">
                <tr>
                    <th>Operador</th>
                    <th>Uso</th>
                    <th>Descripción</th>
                </tr>
                <tr>
                    <td>AND Lógico (&&)</td>
                    <td>expr1 && expr2</td>
                    <td>Devuelve expr1 si se puede convertir a false; de lo contrario, devuelve expr2. Por lo tanto, cuando se usa con valores booleanos, && devuelve true si ambos operandos son true; de lo contrario, devuelve false.</td>
                </tr>
                <tr>
                    <td>OR lógico (||)</td>
                    <td>expr1 || expr2</td>
                    <td>Devuelve expr1 si se puede convertir a true; de lo contrario, devuelve expr2. Por lo tanto, cuando se usa con valores booleanos, || devuelve true si alguno de los operandos es true; si ambos son falsos, devuelve false.</td>
                </tr>
                <tr>
                    <td>NOT lógico (!)</td>
                    <td>!expr</td>
                    <td>Devuelve false si su único operando se puede convertir a true; de lo contrario, devuelve true.</td>
                </tr>
            </table>
        </li> <br>
        <li>Operadores de cadena: además de los operadores de comparación, que se pueden usar en valores de cadena, el operador de concatenación (+) concatena dos valores de cadena, devolviendo otra cadena que es la unión de los dos operandos de cadena.<br>Por ejemplo: <br> <img src="Imagenes/Operador_Cadena.png" alt="Operador de Cadena"> <br><br>
        El operador de asignación abreviada += también se puede utilizar para concatenar cadenas. <br>Por ejemplo:<br> <img src="Imagenes/Operador_Cadena_2.png" alt="Operador de Asignacion Abreviada"> <br><br>
        </li>
        <li>Operador condicional: es el único operador de JavaScript que toma tres operandos. El operador puede tener uno de dos valores según una condición. La sintaxis es: <br> <img src="Imagenes/Operador_Condicional.png" alt="Operador Condicional"> <br><br>
        Si condition es true, el operador tiene el valor de val1. De lo contrario, tiene el valor de val2. Puedes utilizar el operador condicional en cualquier lugar donde normalmente utilizas un operador estándar. <br> Por ejemplo: <br> <img src="Imagenes/Operador_Condicional_2.png" alt="Operador Condicional Ejemplo"> <br><br> Esta declaración asigna el valor "adult" a la variable status si age es de dieciocho años o más. De lo contrario, asigna el valor "minor" a status. <br>
        </li>

        <li>Operador coma (,): simplemente evalúa ambos operandos y devuelve el valor del último operando. Este operador se utiliza principalmente dentro de un bucle for, para permitir que se actualicen múltiples variables cada vez a través del bucle. Se considera de mal estilo usarlo en otros lugares, cuando no es necesario. A menudo, en su lugar pueden y se deben utilizar dos declaraciones independientes. <br> Por ejemplo, si a es un arreglo bidimensional con 10 elementos en un lado, el siguiente código usa el operador coma para actualizar dos variables a la vez. El código imprime los valores de los elementos diagonales en el arreglo: <br> <img src="Imagenes/Operador_Coma.png" alt="Operador Coma"></li> <br><br>
        <li> Operación unaria: es una operación con un solo operando, "delete". Este elimina la propiedad de un objeto. La sintaxis es: <br> <img src="Imagenes/Operador_Unario.png" alt="Operador Unario"> <br> 
        Donde object es el nombre de un objeto, property es una propiedad existente y propertyKey es una cadena o símbolo que hace referencia a una propiedad existente. <br>

        La cuarta forma es legal solo dentro de una declaración with, para eliminar una propiedad de un objeto, y también para las propiedades del objeto global. <br>
            
        Si el operador delete tiene éxito, elimina la propiedad del objeto. Intentar acceder a él después dará como resultado undefined. El operador delete devuelve true si la operación es posible; devuelve false si la operación no es posible. <br>
        <img src="Imagenes/Operador_Unario_2.png" alt="Operador Unario Ejemplo"> <br><br>
        </li>
        <li>Operador relacional: compara sus operandos y devuelve un valor Boolean basado en si la comparación es verdadera. El operador in devuelve true si la propiedad especificada está en el objeto especificado. La sintaxis es: <br> <img src="Imagenes/Operador_Racional.png" alt="Operador Relacional"> <br>Donde propNameOrNumber es una expresión de cadena, numérica o de símbolo que representa un nombre de propiedad o índice de arreglo, y objectName es el nombre de un objeto. <br>
        Los siguientes ejemplos muestran algunos usos del operador in. <br> <img src="Imagenes/Operador_Racional_2.png" alt="Operador Relacional"> <br><br>
        El operador instanceof devuelve true si el objeto especificado es del tipo de objeto especificado. La sintaxis es: <br> <img src="Imagenes/Operador_Relacional_3.png" alt="Operador Relacional"> <br> Donde objectName es el nombre del objeto para comparar con objectType, y objectType es un tipo de objeto, como Date o Array. <br> Utiliza instanceof cuando necesites confirmar el tipo de un objeto en tiempo de ejecución. Por ejemplo, al detectar excepciones, puedes ramificar a diferentes controladores según el tipo de excepción lanzada. <br> Por ejemplo, el siguiente código usa instanceof para determinar si theDay es un objeto Date. Debido a que theDay es un objeto Date, las instrucciones de la expresión if se ejecutan. <br> <img src="Imagenes/Operador_Relacional_4.png" alt="Operador Relacional">
        </li>
    </ul>
    </p>
    <p>6) Las estructuras de control en JS son: <br>
        <ul>
            <li>If: Si ocurre algo, haz lo siguiente</li>
            <li>If/Else:Si ocurre algo, haz esto, sino, haz lo esto otro</li>
            <li>Switch: Se utiliza para hacer diferentes acciones basadas en diferentes condiciones.</li>
            <li>While: Mientras se cumpla la condición realizar estas acciones. Cuando la condición deje de cumplirse salimos del bucle.</li>
            <li>Do While: Ejecute el bucle hasta que se cumpla la condición.</li>
            <li>For: Se utiliza para repetir una o más instrucciones un determinado número de veces</li>
            <li>Try Catch: Try: Intenta un bloque de intrucciones y especifica una respuesta, en caso de una excepción se ejecuta lo que este dentro del bloque catch.</li>
            <li>Break y Continue: Break: Salir/Saltar fuera un bucle, finalizándolo, Continue: Saltar hasta la siguiente iteración del bucle. Permite saltar una o más iteraciones.</li>
        </ul> <br>
    </p>
    <p>7) Las siglas DOM significan Document Object Model, o lo que es lo mismo, la estructura del documento HTML. Una página HTML está formada por múltiples etiquetas HTML, anidadas una dentro de otra, formando un árbol de etiquetas relacionadas entre sí, que se denomina árbol DOM (o simplemente DOM). <br> En Javascript, cuando nos referimos al DOM nos referimos a esta estructura, que podemos modificar de forma dinámica desde Javascript, añadiendo nuevas etiquetas, modificando o eliminando otras, cambiando sus atributos HTML, añadiendo clases, cambiando el contenido de texto, etc. <br> Al estar "amparado" por un lenguaje de programación, todas estas tareas se pueden automatizar, incluso indicando que se realicen cuando el usuario haga acciones determinadas, como por ejemplo: pulsar un botón, mover el ratón, hacer click en una parte del documento, escribir un texto, etc.
    </p> <br>
    <p>8) el Object Map tiene como funcion crear un nuevo array con los resultados de la llamada a la función indicada aplicados a cada uno de sus elementos. <br> <img src="Imagenes/Object_Map.png" alt="Object Map"> <br> Su sintaxis es: <br> <img src="Imagenes/Object_Map_Ej.png" alt="Object Map Ej">
    </p> <br><br>
</body>
</html>